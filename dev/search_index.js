var documenterSearchIndex = {"docs":
[{"location":"#CropGrowth.jl","page":"Home","title":"CropGrowth.jl","text":"CropGrowth.jl is a Julia package for modelling crop growth curves using the generalised logistic function:\n\ny(t) = A + K-A over C + (Qe^-Bt)^1v\n\nwhere:\n\ny(t): biomass at time t (not part of the struct)\nA: lower asymptote (initial or minimum biomass)\nK: positively affects the upper asymptote. This be the final or maximum biomass if:\nC = 100, since:\ny_max = A + (K-A)C^1v, then \ny_max = A + K - A, therefore: \ny_max = K\nC: negatively affects the final or maximum biomass\nQ: negatively affects initial or minimum biomass\ne: Euler's number (~2.71828)\nB: growth rate\nv: asymmetry parameter (v  0; small values: fast growth early; large values: fast growth later)\n\nTo solve for t at specific y:\n\nt(y) = -1 over B log left(  left( K - A over y - A right)^v - C  over Q right) \n\nThe GenomicBreeding module provides a comprehensive suite of tools for genomic prediction, genome-wide association studies (GWAS), and data handling in genomic breeding. It integrates functionalities from GenomicBreedingCore, GenomicBreedingIO, GenomicBreedingModels, and GenomicBreedingPlots to offer efficient and scalable solutions for genetic data analysis and visualisation.\n\nPages = [\"index.md\"]\nDepth = 3","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"We designed GenomicBreeding.jl to work on an HPC running Linux (the various components, i.e. GenomicBreedingCore.jl, GenomicBreedingIO.jl, GenomicBreedingModels.jl, and GenomicBreedingPlots.jl work on a single Linux PC too).\n\nFirst, if you have not yet, please install Julia (the latest version as we aim to update this package for the latest Julia release):\n\ncurl -fsSL https://install.julialang.org | sh\ntype -a julia\n\nInstall the CropGrowth.jl library in Julia:\n\nusing Pkg\nPkg.add(\"https://github.com/jeffersonfparil/CropGrowth.jl\")","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"The main API is the fitgrowthmodels() function:\n\nusing Pkg\nPkg.add(CropGrowth)\nusing CropGrowth\ndf = simulate()\ndf_out = fitgrowthmodels(df, verbose=true)","category":"section"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"#CropGrowth.GrowthModel","page":"Home","title":"CropGrowth.GrowthModel","text":"struct GrowthModel\n\nHolds parameters for the generalized logistic growth model:\n\ny(t) = A + fracK-AC + (Qe^-Bt)^1v\n\nwhere:\n\ny(t): biomass at time t (not part of the struct)\nA: lower asymptote (initial or minimum biomass)\nK: positively affects the upper asymptote (can be the final or maximum biomass if C = 100, since y_max = A + (K-A)C^(1v), then y_max = A + K - A, therefore: y_max = K)\nC: negatively affects the final or maximum biomass\nQ: negatively affects initial or minimum biomass\ne: Euler's number (~2.71828)\nB: growth rate\nv: asymmetry parameter (v  0; small values: fast growth early; large values: fast growth later)\n\nAdditional information are provided in the struct:\n\ny_max: maximum value of the growth model (y_max = A + (K-A)C^(1v))\nfit_statistics: a dictionary containing fit statistics such as R², RMSE, MSE, MAE, and Pearson's correlation coefficient (ρ)\n\nConstructor\n\nGrowthModel(;     A::Float64,     K::Float64,     C::Float64,     Q::Float64,     B::Float64,     v::Float64,     fit_statistics::Dict{String,Float64} = Dict(\"\"=>NaN),     ϵ::Float64 = 1e-12, )\n\nNotes:\n\nThe struct includes a constructor that automatically calculates y_max based on the provided parameters.\nThe fit_statistics field is optional and defaults to a dictionary with a single entry of an empty string key and NaN value.\nA small epsilon value (ϵ) is added to the calculation of y_max to prevent division by zero errors.\n\nExample\n\njulia> growth_model = GrowthModel(A=0.0, K=10.0, C=1.0, Q=1.0, B=0.75, v=0.1);\n\njulia> (growth_model.y_max - growth_model.K) < 1e-9\ntrue\n\njulia> (growth_model.y_max - 10.0) < 1e-9\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#CropGrowth.fitgrowthmodels-Tuple{DataFrames.DataFrame}","page":"Home","title":"CropGrowth.fitgrowthmodels","text":"fitgrowthmodels(\n    df::DataFrame;\n    A = Dict(\n        :init=>minimum(select(df, Not(REQUIRED_COLUMNS))[:, 1]),\n        :lower=>0.0,\n        :upper=>maximum(select(df, Not(REQUIRED_COLUMNS))[:, 1]),\n    ),\n    K = Dict(\n        :init=>maximum(select(df, Not(REQUIRED_COLUMNS))[:, 1]),\n        :lower=>0.0,\n        :upper=>2*maximum(select(df, Not(REQUIRED_COLUMNS))[:, 1]),\n    ),\n    C = Dict(:init=>1.0, :lower=>1.0, :upper=>1.0),\n    Q = Dict(:init=>1.0, :lower=>1.0, :upper=>1.0),\n    B = Dict(:init=>1.0, :lower=>0.0, :upper=>10.0),\n    v = Dict(:init=>1.0, :lower=>1e-5, :upper=>10.0),\n    min_t::Int64 = 3,\n    perc_of_final::Vector{Float64} = [0.5, 0.9],\n    fit_statistic::String = \"R²\",\n    maxiters::Int64 = 10_000,\n    seed::Int64 = 42,\n    show_plots::Bool = false,\n    verbose::Bool = false,\n)::Tuple{DataFrame, Vector{String}}\n\nFits generalized logistic growth models to the data provided in the input DataFrame and returns a DataFrame containing the fitted parameters, fit statistics, and time to reach specified percentages of the final value.\n\nArguments\n\ndf::DataFrame: Input data containing the required columns specified in REQUIRED_COLUMNS and at least one trait column.\nA::Dict: Search space for the parameter A (lower asymptote). Contains :init, :lower, and :upper keys. Defaults to the minimum and maximum of the trait column with init=minimum.\nK::Dict: Search space for the parameter K (upper asymptote). Contains :init, :lower, and :upper keys. Defaults to the minimum and 2×maximum of the trait column with init=maximum.\nC::Dict: Search space for the parameter C. Contains :init, :lower, and :upper keys. Defaults to init=1.0, lower=1.0, upper=1.0.\nQ::Dict: Search space for the parameter Q. Contains :init, :lower, and :upper keys. Defaults to init=1.0, lower=1.0, upper=1.0.\nB::Dict: Search space for the parameter B (growth rate). Contains :init, :lower, and :upper keys. Defaults to init=1.0, lower=0.0, upper=10.0.\nv::Dict: Search space for the parameter v (asymmetry parameter). Contains :init, :lower, and :upper keys. Defaults to init=1.0, lower=1e-5, upper=10.0.\nmin_t::Int64: Minimum number of time points required to fit the growth model for a specific combination of entry, site, replication, and growing period. Defaults to 3.\nperc_of_final::Vector{Float64}: Percentages of the final value for which the time to reach these percentages will be calculated. Defaults to [0.5, 0.9].\nfit_statistic::String: The fit statistic to be used for evaluating the model. Must be one of [\"R²\", \"RMSE\", \"MSE\", \"MAE\", \"ρ\"]. Defaults to \"R²\".\nmaxiters::Int64: Maximum number of iterations allowed for the optimization process. Defaults to 10_000.\nseed::Int64: Random seed for reproducibility. Defaults to 42.\nshow_plots::Bool: Whether to show fitted growth curve plots. Defaults to false.\nverbose::Bool: Whether to display progress and additional information during the fitting process. Defaults to false.\n\nReturns\n\nDataFrame: A DataFrame containing the fitted parameters (A, K, C, Q, B, v), fit statistics, maximum value of the growth model (y_max), and time to reach specified percentages of the final value for each combination of entry, site, replication, and growing period.\n\nNotes\n\nThe input DataFrame must contain the required columns specified in the global variable REQUIRED_COLUMNS, as well as at least one additional trait column.\nIf the DataFrame contains more than one trait column, only the first trait column will be used.\nCombinations with fewer than min_t time points will be skipped, and a warning will be issued.\nThe function uses a progress bar to indicate the fitting process if verbose=true.\n\nDetails\n\nFits a generalized logistic growth model to the data using the following equation:\n\ny(t) = A + fracK-AC + (Qe^-Bt)^1v\n\nwhere:\n\ny(t): biomass at time t\nA: lower asymptote (initial or minimum biomass)\nK: positively affects the upper asymptote (can be the final or maximum biomass if C = 100, since y_max = A + (K-A)C^(1v), then y_max = A + K - A, therefore: y_max = K)\nC: negatively affects the final or maximum biomass\nQ: negatively affects initial or minimum biomass\ne: Euler's number (~2.71828)\nB: growth rate\nv: asymmetry parameter (v  0; small values: fast growth early; large values: fast growth later)\n\nAdditional information are provided in the output DataFrame:\n\nMaximum value of the growth model (y_max = A + (K-A)C^(1v))\nOne of the following fit statistic such as R² (default), RMSE, MSE, MAE, and Pearson's correlation coefficient (ρ)\n\nExample\n\njulia> df = simulate(n_entries=5, seed=42);\n\njulia> df_out, skipped_combinations = fitgrowthmodels(df);\n\njulia> length(unique(df.entries)) == length(unique(df_out.entries))\ntrue\n\njulia> length(unique(df.sites)) == length(unique(df_out.sites))\ntrue\n\njulia> length(unique(df.replications)) == length(unique(df_out.replications))\ntrue\n\njulia> length(unique(df.growing_periods)) == length(unique(df_out.growing_periods))\ntrue\n\njulia> all(x -> x ∈ names(df_out), [\"A\", \"K\", \"C\", \"Q\", \"B\", \"v\", \"y_max\", \"R²\", \"time_to_50p\", \"time_to_90p\"])\ntrue\n\njulia> (var(df_out.A) > 0.0) && (var(df_out.K) > 0.0) && (var(df_out.C) == 0.0) && (var(df_out.Q) == 0.0) && (var(df_out.B) > 0.0) && (var(df_out.v) > 0.0)\ntrue\n\njulia> (var(df_out.y_max) > 0.0) && (var(df_out.\"R²\") > 0.0) && (var(df_out.time_to_50p) > 0.0) && (var(df_out.time_to_90p) > 0.0)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#CropGrowth.fitstatistics-Tuple{}","page":"Home","title":"CropGrowth.fitstatistics","text":"fitstatistics(; y::Vector{Float64}, ŷ::Vector{Float64})::Dict{String, Float64}\n\nCompute various fit statistics for a given set of observed and predicted values.\n\nArguments\n\ny::Vector{Float64}: Observed data points.\nŷ::Vector{Float64}: Predicted data points.\n\nReturns\n\nA dictionary containing the following fit statistics:\n\n\"R²\": Coefficient of determination, a measure of how well the predicted values explain the variance in the observed data.\n\"rmse\": Root mean squared error, a measure of the average magnitude of the residuals.\n\"mse\": Mean squared error, the average of the squared residuals.\n\"mae\": Mean absolute error, the average of the absolute residuals.\n\"ρ\": Pearson correlation coefficient between the observed and predicted values.\n\nNotes\n\nEnsure that the y and ŷ vectors are of the same length and correspond to the same observations.\nThe function assumes that both y and ŷ are non-empty vectors.\n\nExample\n\njulia> y1::Vector{Float64} = rand(10); y2::Vector{Float64} = rand(10);\n\njulia> stats0 = fitstatistics(y=y1, ŷ=y1);\n\njulia> stats1 = fitstatistics(y=y1, ŷ=y2);\n\njulia> stats0[\"R²\"] > stats1[\"R²\"]\ntrue\n\njulia> stats0[\"rmse\"] < stats1[\"rmse\"]\ntrue\n\njulia> stats0[\"mse\"] < stats1[\"mse\"]\ntrue\n\njulia> stats0[\"mae\"] < stats1[\"mae\"]\ntrue\n\njulia> stats0[\"ρ\"] > stats1[\"ρ\"]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#CropGrowth.generalisedlogistic-Tuple{GrowthModel}","page":"Home","title":"CropGrowth.generalisedlogistic","text":"generalisedlogistic(growth_model::GrowthModel; t::Vector{Float64})::Vector{Float64}\n\nComputes the generalized logistic function for a given vector of time points t using the parameters defined in the GrowthModel.\n\nArguments\n\ngrowth_model::GrowthModel: A struct containing the parameters for the generalized logistic function.\nt::Vector{Float64}: A vector of time points at which to evaluate the function.\n\nReturns\n\nVector{Float64}: A vector of values representing the generalized logistic function evaluated at each time point in t.\n\nReturns\n\nVector{Float64}: A vector of values representing the generalized logistic function evaluated at each time point in t.\n\nExample\n\njulia> t = collect(0.0:1.0:10.0);\n\njulia> growth_model = GrowthModel(A=0.0, K=10.0, C=1.0, Q=1.0, B=0.75, v=0.1);\n\njulia> y = generalisedlogistic(growth_model, t=t);\n\njulia> (y[1] == minimum(y)) && (y[end] == maximum(y))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#CropGrowth.generalisedlogistic-Tuple{Vector{Float64}}","page":"Home","title":"CropGrowth.generalisedlogistic","text":"generalisedlogistic(t::Vector{Float64}; A=0.0, K=1.0, C=1.0, Q=1.0, B=1.0, v=1.0)::Vector{Float64}\n\nComputes the generalized logistic function for a given vector of time points t.\n\nArguments\n\nt::Vector{Float64}: A vector of time points at which to evaluate the function.\n\nKeyword Arguments\n\nA::Float64 (default: 0.0): lower asymptote (initial or minimum biomass)\nK::Float64 (default: 1.0): upper asymptote (can be the final or maximum biomass if C = 100, since y_max = A + (K-A)C^(1v), then y_max = A + K - A, therefore: y_max = K)\nC::Float64 (default: 1.0): negatively affects the final or maximum biomass\nQ::Float64 (default: 1.0): negatively affects initial or minimum biomass\nB::Float64 (default: 1.0): growth rate\nv::Float64 (default: 1.0): asymmetry parameter (v  0; small values: fast growth early; large values: fast growth later)\n\nReturns\n\nVector{Float64}: A vector of values representing the generalized logistic function evaluated at each time point in t.\n\nExample\n\njulia> t = collect(0.0:1.0:10.0);\n\njulia> y = generalisedlogistic(t; A=0.0, K=10.0, C=1.0, Q=1.0, B=0.75, v=0.1);\n\njulia> (y[1] == minimum(y)) && (y[end] == maximum(y))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#CropGrowth.modelgrowth-Tuple{}","page":"Home","title":"CropGrowth.modelgrowth","text":"modelgrowth(; \n    y::Vector{Float64}, \n    t::Vector{Float64}, \n    θ_search_space::Dict{String, Dict{Symbol, Float64}}, \n    maxiters::Int64=10_000, \n    seed::Int64=42, \n    verbose::Bool=false\n)::GrowthModel\n\nFit a generalized logistic growth model to the given data y over time t.\n\nArguments\n\ny::Vector{Float64}: The observed data points representing the growth values.\nt::Vector{Float64}: The corresponding time points for the observed data.\nθ_search_space::Dict{String, Dict{Symbol, Float64}}: A dictionary defining the search space for each parameter of the generalized logistic model. Each key corresponds to a parameter name (\"A\", \"K\", \"C\", \"Q\", \"B\", \"v\"), and the value is another dictionary with keys :init, :lower, and :upper specifying the initial value, lower bound, and upper bound for that parameter.\nmaxiters::Int64=10_000: The maximum number of iterations for the optimization algorithm. Defaults to 10,000.\nseed::Int64=42: The random seed for reproducibility. Defaults to 42.\nverbose::Bool=false: If true, prints the fitted parameters, fit statistics, and displays a plot of the fitted model. Defaults to false.\n\nReturns\n\nGrowthModel: A structure containing the fitted parameters of the generalized logistic growth model and fit statistics.\n\nDetails\n\nThe function uses an optimization algorithm to minimize the mean squared error between the observed data y and the generalized logistic model. \nThe model parameters are constrained within bounds specified in the θ_search_space dictionary.\nThe optimization is performed using the BBO_adaptive_de_rand_1_bin_radiuslimited() algorithm.\nThe function also computes fit statistics, which are included in the returned GrowthModel structure.\nIf verbose is set to true, the function prints the fitted parameters, fit statistics, and displays a scatter plot of the observed data along with the fitted curve.\n\nNotes\n\ny_max may be unexpectedly high if C is fitted freely which may indicate a simple linear growth rather than a logistic growth pattern.\nIf y_max is desired to be equal to K, set C = 1.0 when defining the θ_search_space, i.e. In θ_search_space define \"C\" => Dict(:init=>1.0, :lower=>1.0, :upper=>1.0).\n\nExample\n\njulia> t = collect(1.0:10.0);\n\njulia> growth_model_1 = modelgrowth(t=t, y=sort(vcat([0.0, 0.0, 1.0, 1.0], rand(6))));\n\njulia> growth_model_2 = modelgrowth(t=t, y=rand(10));\n\njulia> growth_model_1.fit_statistics[\"R²\"] > growth_model_2.fit_statistics[\"R²\"]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#CropGrowth.readdelimited-Tuple{}","page":"Home","title":"CropGrowth.readdelimited","text":"readdelimited(; fname::String, delim::Union{Char,String} = \"\t\", trait_name::String = \"biomass\")::DataFrame\n\nReads a delimited file into a DataFrame and validates its structure.\n\nArguments\n\nfname::String: The path to the file to be read.\ndelim::Union{Char,String}: The delimiter used in the file. Defaults to tab (\"\t\").\ntrait_name::String: The name of the trait column to validate. Defaults to \"biomass\".\n\nReturns\n\nA DataFrame containing the data from the file with the following required columns:\nentries\nsites\nreplications\ngrowing_periods\ntime_points\nThe column specified by trait_name\n\nThrows\n\nArgumentError: If the file does not exist.\nArgumentError: If any of the required columns, including trait_name, are missing.\n\nNotes\n\nThe function expects the file to contain specific required columns, defined in REQUIRED_COLUMNS, along with the column specified by trait_name.\n\nExample\n\njulia> df = simulate();\n\njulia> CSV.write(\"test.tsv\", df, delim=\"\t\");\n\njulia> df_read = readdelimited(fname=\"test.tsv\", delim=\"\t\", trait_name=\"biomass\");\n\njulia> isequal(df, df_read)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#CropGrowth.simulate-Tuple{}","page":"Home","title":"CropGrowth.simulate","text":"simulate(; \n    n_entries::Int64 = 100, \n    n_sites::Int64 = 2, \n    n_replications::Int64 = 3, \n    n_growing_periods::Int64 = 4, \n    n_time_points_per_growing_period::Int64 = 10, \n    seed::Int64 = 42\n)::DataFrame\n\nSimulates crop growth data and returns it as a DataFrame. The function generates synthetic data for multiple entries, sites, replications, growing periods, and time points, with random biomass values.\n\nKeyword Arguments\n\nn_entries::Int64: Number of crop entries to simulate (default: 100).\nn_sites::Int64: Number of sites to simulate (default: 2).\nn_replications::Int64: Number of replications per site (default: 3).\nn_growing_periods::Int64: Number of growing periods per replication (default: 4).\nn_time_points_per_growing_period::Int64: Number of time points per growing period (default: 10).\nseed::Int64: Random seed for reproducibility (default: 42).\n\nReturns\n\nA DataFrame with the following columns:\n\nentries: Crop entry identifiers.\nsites: Site identifiers.\nreplications: Replication identifiers.\ngrowing_periods: Growing period identifiers.\ntime_points: Time points within each growing period.\nbiomass: Simulated biomass values.\n\nExample\n\njulia> df = simulate(n_entries=5, n_sites=1, n_replications=1, n_growing_periods=1, n_time_points_per_growing_period=5, trait_name=\"some_trait_name\", seed=123);\n\njulia> size(df)\n(25, 6)\n\njulia> var(df.some_trait_name) > 0.0\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#CropGrowth.timetomaxperc-Tuple{GrowthModel}","page":"Home","title":"CropGrowth.timetomaxperc","text":"timetomaxperc(growth_model::GrowthModel; p::Vector{Float64} = [0.5])::Vector{Float64}\n\nCalculate the time required for a growth model to reach a proportion p of its carrying capacity K.\n\nArguments\n\ngrowth_model::GrowthModel: An instance of the GrowthModel type containing the parameters of the growth model.\np::Vector{Float64}: A vector of proportions (default is [0.5]) representing the fraction of the carrying capacity K to compute the time for.\n\nReturns\n\nVector{Float64}: A vector of times corresponding to each proportion in p.\n\nDetails\n\nThe function computes the maximum value of the growth model (y_max = A + (K-A)C^(1v)) based on its parameters.\nFor each proportion in p, the corresponding value of y is calculated as p * y_max.\nThe time required to reach each y is computed using the generalised logistic growth model formula, which involves logarithmic and complex arithmetic operations.\nThe result is the real part of the computed times.\nThe formula is:\n\nt = -frac1B cdot ln left( fracleft( left( fracK - Ay - A right)^v - C right)Q right)\n\nNotes\n\nThe function assumes that the GrowthModel instance contains the parameters A, K, C, Q, B, and v.\nThe computation may involve complex numbers, but only the real part of the result is returned.\n\nExample\n\njulia> growth_model = modelgrowth(t=collect(1.0:10.0), y=sort(vcat([0.0, 0.0, 1.0, 1.0], rand(6))));\n\njulia> p = [0.5, 0.95, 0.99];\n\njulia> time_to_Kp = timetomaxperc(growth_model; p=p);\n\njulia> ŷ = generalisedlogistic(growth_model, t=time_to_Kp);\n\njulia> all( abs.(ŷ .- (p .* growth_model.y_max)) .< 1e-5 )\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#CropGrowth.writedelimited-Tuple{DataFrames.DataFrame}","page":"Home","title":"CropGrowth.writedelimited","text":"writedelimited(df::DataFrame; fname::String, delim::Union{Char,String} = \"\t\", overwrite::Bool = false)::Nothing\n\nWrites the contents of a DataFrame to a delimited text file.\n\nArguments\n\ndf::DataFrame: The data frame to be written to the file. Must contain the required columns:\nentries\nsites\nreplications\ngrowing_periods\ntime_points\n1 additional column representing the trait data\nfname::String: The name of the output file, including its path if necessary.\ndelim::Union{Char,String}: The delimiter to use in the output file. Defaults to a tab character (\"\t\").\noverwrite::Bool: Whether to overwrite the file if it already exists. Defaults to false.\n\nReturns\n\nNothing: This function does not return a value.\n\nExample\n\njulia> df = simulate();\n\njulia> fname = writedelimited(df, fname=\"test.tsv\", delim=\"\t\", overwrite=true);\n\njulia> isfile(fname)\ntrue\n\njulia> df_read = readdelimited(fname=\"test.tsv\", delim=\"\t\", trait_name=\"biomass\");\n\njulia> isequal(df, df_read)\ntrue\n\n\n\n\n\n","category":"method"}]
}

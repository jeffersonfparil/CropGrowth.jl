var documenterSearchIndex = {"docs":
[{"location":"#CropGrowth.jl","page":"Home","title":"CropGrowth.jl","text":"Pages = [\"index.md\"]\nDepth = 3\n\nCropGrowth.jl is a Julia package for modelling crop growth curves using the generalised logistic function:","category":"section"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"using Pkg\nPkg.add(CropGrowth)\nusing CropGrowth\ndf = simulate()\ndf_out = fitgrowthmodels(df, verbose=true)","category":"section"},{"location":"#Model","page":"Home","title":"Model","text":"y(t) = A + K-A over C + (Qe^-Bt)^1v\n\nwhere:\n\ny(t): biomass at time t\nA: lower asymptote (initial or minimum biomass)\nK: positively affects the upper asymptote. This is the final or maximum biomass if:\nC = 100, since:\ny_max = A + (K-A)C^1v, then \ny_max = A + K - A, therefore: \ny_max = K\nC: negatively affects the final or maximum biomass\nQ: negatively affects initial or minimum biomass\ne: Euler's number (~2.71828)\nB: growth rate\nv: asymmetry parameter (v  0; small values: fast growth early; large values: fast growth later)\n\nTo solve for t at specific y:\n\nt(y) = -1 over B log left(  1 over Q left( left( K - A over y - A right)^v - C right)  right) ","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Please install the latest version of Julia (we aim to update CropGrowth.jl for the latest Julia release):\n\ncurl -fsSL https://install.julialang.org | sh\ntype -a julia\n\nInstall the CropGrowth.jl library in Julia:\n\nStable version:\n\nusing Pkg\nPkg.add(CropGrowth)\n\nDevelopment version:\n\nusing Pkg\nPkg.add(\"https://github.com/jeffersonfparil/CropGrowth.jl\")\n\nTest the installation in Julia:\n\nusing CropGrowth\ndf = simulate()\ndf_out = fitgrowthmodels(df, verbose=true)","category":"section"},{"location":"#Implementation-details","page":"Home","title":"Implementation details","text":"The main function, fitgrowthmodels fits generalized logistic growth models to the data provided in the input DataFrame and returns a DataFrame containing the fitted parameters, fit statistics, and time to reach specified fraction of the final value. The complete function signature is:\n\nfitgrowthmodels(\n  df::DataFrame;\n  A = Dict(\n      :init=>minimum(select(df, Not(REQUIRED_COLUMNS))[:, 1]),\n      :lower=>0.0,\n      :upper=>maximum(select(df, Not(REQUIRED_COLUMNS))[:, 1]),\n  ),\n  K = Dict(\n      :init=>maximum(select(df, Not(REQUIRED_COLUMNS))[:, 1]),\n      :lower=>0.0,\n      :upper=>2*maximum(select(df, Not(REQUIRED_COLUMNS))[:, 1]),\n  ),\n  C = Dict(:init=>1.0, :lower=>1.0, :upper=>1.0),\n  Q = Dict(:init=>1.0, :lower=>1.0, :upper=>1.0),\n  B = Dict(:init=>1.0, :lower=>0.0, :upper=>10.0),\n  v = Dict(:init=>1.0, :lower=>1e-5, :upper=>10.0),\n  min_t::Int64 = 3,\n  frac_of_final::Vector{Float64} = [0.5, 0.9],\n  fit_statistic::String = \"R²\",\n  maxiters::Int64 = 10_000,\n  seed::Int64 = 42,\n  show_plots::Bool = false,\n  verbose::Bool = false,\n)::Tuple{DataFrame, Vector{String}}","category":"section"},{"location":"#Arguments","page":"Home","title":"Arguments","text":"df::DataFrame: Input data containing the required columns specified in REQUIRED_COLUMNS = [\"entries\", \"sites\", \"replications\", \"growing_periods\", \"time_points\"] and at least one trait column.\nA::Dict: Search space for the parameter A (lower asymptote). Contains :init, :lower, and :upper keys. Defaults to the minimum and maximum of the trait column with init=minimum.\nK::Dict: Search space for the parameter K (upper asymptote). Contains :init, :lower, and :upper keys. Defaults to the minimum and 2×maximum of the trait column with init=maximum.\nC::Dict: Search space for the parameter C. Contains :init, :lower, and :upper keys. Defaults to init=1.0, lower=1.0, upper=1.0.\nQ::Dict: Search space for the parameter Q. Contains :init, :lower, and :upper keys. Defaults to init=1.0, lower=1.0, upper=1.0.\nB::Dict: Search space for the parameter B (growth rate). Contains :init, :lower, and :upper keys. Defaults to init=1.0, lower=0.0, upper=10.0.\nv::Dict: Search space for the parameter v (asymmetry parameter). Contains :init, :lower, and :upper keys. Defaults to init=1.0, lower=1e-5, upper=10.0.\nmin_t::Int64: Minimum number of time points required to fit the growth model for a specific combination of entry, site, replication, and growing period. Defaults to 3.\nfrac_of_final::Vector{Float64}: Percentages of the final value for which the time to reach these fraction will be calculated. Defaults to [0.5, 0.9].\nfit_statistic::String: The fit statistic to be used for evaluating the model. Must be one of [\"R²\", \"RMSE\", \"MSE\", \"MAE\", \"ρ\"]. Defaults to \"R²\".\nmaxiters::Int64: Maximum number of iterations allowed for the optimization process. Defaults to 10_000.\nseed::Int64: Random seed for reproducibility. Defaults to 42.\nshow_plots::Bool: Whether to show fitted growth curve plots. Defaults to false.\nverbose::Bool: Whether to display progress and additional information during the fitting process. Defaults to false.","category":"section"},{"location":"#Returns","page":"Home","title":"Returns","text":"Tuple{DataFrame, Vector{String}}: \n\nThe first element is a DataFrame containing the fitted parameters (A, K, C, Q, B, v), fit statistics, value of the growth models at t=0 (y_t0), maximum value of the growth model (y_max), and time to reach specified fraction of the final value for each combination of entry, site, replication, and growing period.\nThe second element is a Vector{String} containing the combinations that were skipped due to insufficient data points.","category":"section"},{"location":"#Notes","page":"Home","title":"Notes","text":"The input DataFrame must contain the required columns specified in the global variable REQUIRED_COLUMNS = [\"entries\", \"sites\", \"replications\", \"growing_periods\", \"time_points\"], as well as at least one additional trait column.\nIf the DataFrame contains more than one trait column, only the first trait column will be used.\nCombinations with fewer than min_t time points will be skipped.\nThe function uses a progress bar to indicate the fitting process if verbose=true.\nThe optimisation is performed using the BBO_adaptive_de_rand_1_bin_radiuslimited() algorithm (details of the optimisation algorithm).\nThe optimisation algorithm minimises the mean squared error between the observed data y and the generalised logistic model. ","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"using CropGrowth, StatsBase\ndf = simulate(n_entries=5, n_sites=1, n_replications=1, n_growing_periods=1, n_time_points_per_growing_period=5, seed=123)\ndf_out_0, skipped_combinations_0 = fitgrowthmodels(df, show_plots=true)\ndf_out_C, skipped_combinations_C = fitgrowthmodels(df, C=Dict(:init=>1.0, :lower=>0.0, :upper=>100.0), show_plots=true)\ndf_out_Q, skipped_combinations_Q = fitgrowthmodels(df, Q=Dict(:init=>1.0, :lower=>0.0, :upper=>100.0), show_plots=true)\ndf_out_CQ, skipped_combinations_CQ = fitgrowthmodels(\n    df,\n    C=Dict(:init=>1.0, :lower=>0.0, :upper=>5.0),\n    Q=Dict(:init=>1.0, :lower=>0.0, :upper=>5.0),\n    show_plots=true\n)\nmean(df_out_0.R²)\nmean(df_out_C.R²)\nmean(df_out_Q.R²)\nmean(df_out_CQ.R²)","category":"section"},{"location":"#Comparison-with-nplr","page":"Home","title":"Comparison with nplr","text":"TLDR: CropGrowth.jl fits a more general logistic function than nplr.\n\nThe R package nplr: n-parameter logistic regressions fits a variant of the logistic model. It fits 5 parameters instead of the 6 parameters in CropGrowth.jl's formulation above. The model is defined as:\n\ny(x) = \n  B + \n    T - B \n    over \n    left  1 + 10^b(x_mid - x) right ^s\n  \n\n\nwhere:\n\nB: lower asymptote\nT: upper asymptote\nb: Hill slope (related to B or growth rate)\nx_mid: x-coordinate at the inflexion point,\ns asymetry coefficient (related to v)\n\nFitting log10(dose)-response curve with nplr:\n\nlibrary(nplr)\nlibrary(txtplot)\npath <- system.file(\"extdata\", \"pc3.txt\", package=\"nplr\")\npc3 <- read.delim(path)\ntxtplot::txtplot(log10(pc3$CONC), pc3$GIPROP) # nplr default does log10(x)\nnp1 <- nplr::nplr(x=pc3$CONC, y=pc3$GIPROP, useLog=TRUE)\ny = pc3$GIPROP\ny_hat = np1@yFit\nprint(\"Fitted parameters:\")\nprint(paste0(\"K = \", np1@pars$bottom))\nprint(paste0(\"A = \", np1@pars$top))\nprint(paste0(\"xmid = \", np1@pars$xmid))\nprint(paste0(\"B_ish = \", np1@pars$scal))\nprint(paste0(\"v_ish = \", np1@pars$scal))\nprint(\"Fit statistics:\")\nprint(paste0(\"mae = \", mean(abs(y - y_hat))))\nprint(paste0(\"mse = \", mean((y - y_hat)^2)))\nprint(paste0(\"rmse = \", sqrt(mean((y - y_hat)^2))))\nprint(paste0(\"cor = \", cor(y, y_hat)))\nprint(paste0(\"r2 = \", 1 - (var((y - y_hat)) / var(y))))\n# [1] \"Fitted parameters:\"\n# [1] \"K = 0.000182956669824204\"\n# [1] \"A = 0.996490622312222\"\n# [1] \"xmid = -6.18254538738321\"\n# [1] \"B_ish = -1.42800873142546\"\n# [1] \"v_ish = -1.42800873142546\"\n# [1] \"Fit statistics:\"\n# [1] \"mae = 0.0186073781104083\"\n# [1] \"mse = 0.000651821232462819\"\n# [1] \"rmse = 0.0255307898910868\"\n# [1] \"cor = 0.997250250732751\"\n# [1] \"r2 = 0.994444954867448\"\n\nCropGrowth.jl achieves very similar but more generalised fit:\n\nusing DataFrames, CSV, CropGrowth\ndf = CSV.read(expanduser(\"~/.conda/envs/GenomicBreeding/lib/R/library/nplr/extdata/pc3.txt\"), DataFrame)\ngrowth_model = modelgrowth(\n    t = log10.(df.CONC),\n    y = df.GIPROP,\n    maxiters = 100_000,\n    seed = 42,\n    verbose = true,\n)\n# Fitted parameters:\n# A = 0.991559343580949\n# K = 0.0380737475678395\n# C = 1.0\n# Q = 1.5219825671137292e-5\n# B = 1.5916146320430173\n# v = 0.15864685998073122\n# y_t0 = 0.03816521536021922\n# y_max = 0.038073747568793115\n# Fit statistics:\n# mse = 0.0006662392521457019\n# rmse = 0.0258116108010659\n# R² = 0.9943191952067459\n# ρ = 0.9971555521616207\n# mae = 0.020947684621310015","category":"section"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"#CropGrowth.GrowthModel","page":"Home","title":"CropGrowth.GrowthModel","text":"mutable struct GrowthModel\n    A::Float64\n    K::Float64\n    C::Float64\n    Q::Float64\n    B::Float64\n    v::Float64\n    y_t0::Float64\n    y_max::Float64\n    fit_statistics::Dict{String,Float64}\n\nHolds parameters for the generalised logistic growth model:\n\ny(t) = A + fracK-AC + (Qe^-Bt)^1v\n\nwhere:\n\ny(t): biomass at time t (not part of the struct)\nA: lower asymptote (initial or minimum biomass)\nK: positively affects the upper asymptote (can be the final or maximum biomass if C = 100, since y_max = A + (K-A)C^(1v), then y_max = A + K - A, therefore: y_max = K)\nC: negatively affects the final or maximum biomass\nQ: negatively affects initial or minimum biomass\ne: Euler's number (~2.71828)\nB: growth rate\nv: asymmetry parameter (v  0; small values: fast growth early; large values: fast growth later)\n\nAdditional information are provided in the struct:\n\ny_t0: value of the growth model at time t = 0\ny_max: maximum value of the growth model (y_max = A + (K-A)C^(1v))\nfit_statistics: a dictionary containing fit statistics such as R², RMSE, MSE, MAE, and Pearson's correlation coefficient (ρ)\n\nConstructor\n\nGrowthModel(;\n    A::Float64,\n    K::Float64,\n    C::Float64,\n    Q::Float64,\n    B::Float64,\n    v::Float64,\n    fit_statistics::Dict{String,Float64} = Dict(\"\"=>NaN),\n    ϵ::Float64 = 1e-12,\n)\n\nNotes:\n\nThe struct includes a constructor that automatically calculates y_max based on the provided parameters.\nThe fit_statistics field is optional and defaults to a dictionary with a single entry of an empty string key and NaN value.\nA small epsilon value (ϵ) is added to the calculation of y_max to prevent division by zero errors.\n\nExample\n\njulia> growth_model = GrowthModel(A=0.0, K=10.0, C=1.0, Q=1.0, B=0.75, v=0.1);\n\njulia> (growth_model.y_max - growth_model.K) < 1e-9\ntrue\n\njulia> (growth_model.y_max - 10.0) < 1e-9\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#CropGrowth.fitgrowthmodels-Tuple{DataFrames.DataFrame}","page":"Home","title":"CropGrowth.fitgrowthmodels","text":"fitgrowthmodels(\n    df::DataFrame;\n    A = Dict(\n        :init=>minimum(select(df, Not(REQUIRED_COLUMNS))[:, 1]),\n        :lower=>0.0,\n        :upper=>maximum(select(df, Not(REQUIRED_COLUMNS))[:, 1]),\n    ),\n    K = Dict(\n        :init=>maximum(select(df, Not(REQUIRED_COLUMNS))[:, 1]),\n        :lower=>0.0,\n        :upper=>2*maximum(select(df, Not(REQUIRED_COLUMNS))[:, 1]),\n    ),\n    C = Dict(:init=>1.0, :lower=>1.0, :upper=>1.0),\n    Q = Dict(:init=>1.0, :lower=>1.0, :upper=>1.0),\n    B = Dict(:init=>1.0, :lower=>0.0, :upper=>10.0),\n    v = Dict(:init=>1.0, :lower=>1e-5, :upper=>10.0),\n    min_t::Int64 = 3,\n    frac_of_final::Vector{Float64} = [0.5, 0.9],\n    fit_statistic::String = \"R²\",\n    maxiters::Int64 = 10_000,\n    seed::Int64 = 42,\n    show_plots::Bool = false,\n    verbose::Bool = false,\n)::Tuple{DataFrame, Vector{String}}\n\nFits generalised logistic growth models to the data provided in the input DataFrame and returns a DataFrame containing the fitted parameters, fit statistics, and time to reach specified fractions of the final value.\n\nArguments\n\ndf::DataFrame: Input data containing the required columns specified in REQUIRED_COLUMNS = [\"entries\", \"sites\", \"replications\", \"growing_periods\", \"time_points\"] and at least one trait column.\nA::Dict: Search space for the parameter A (lower asymptote). Contains :init, :lower, and :upper keys. Defaults to the minimum and maximum of the trait column with init=minimum.\nK::Dict: Search space for the parameter K (upper asymptote). Contains :init, :lower, and :upper keys. Defaults to the minimum and 2×maximum of the trait column with init=maximum.\nC::Dict: Search space for the parameter C. Contains :init, :lower, and :upper keys. Defaults to init=1.0, lower=1.0, upper=1.0.\nQ::Dict: Search space for the parameter Q. Contains :init, :lower, and :upper keys. Defaults to init=1.0, lower=1.0, upper=1.0.\nB::Dict: Search space for the parameter B (growth rate). Contains :init, :lower, and :upper keys. Defaults to init=1.0, lower=0.0, upper=10.0.\nv::Dict: Search space for the parameter v (asymmetry parameter). Contains :init, :lower, and :upper keys. Defaults to init=1.0, lower=1e-5, upper=10.0.\nmin_t::Int64: Minimum number of time points required to fit the growth model for a specific combination of entry, site, replication, and growing period. Defaults to 3.\nfrac_of_final::Vector{Float64}: Percentages of the final value for which the time to reach these fractions will be calculated. Defaults to [0.5, 0.9].\nfit_statistic::String: The fit statistic to be used for evaluating the model. Must be one of [\"R²\", \"RMSE\", \"MSE\", \"MAE\", \"ρ\"]. Defaults to \"R²\".\nmaxiters::Int64: Maximum number of iterations allowed for the optimisation process. Defaults to 10_000.\nseed::Int64: Random seed for reproducibility. Defaults to 42.\nshow_plots::Bool: Whether to show fitted growth curve plots. Defaults to false.\nverbose::Bool: Whether to display progress and additional information during the fitting process. Defaults to false.\n\nReturns\n\nTuple{DataFrame, Vector{String}}: \nThe first element is a DataFrame containing the fitted parameters (A, K, C, Q, B, v), fit statistics, value of the growth models at t=0 (y_t0), maximum value of the growth model (y_max), and time to reach specified fractions of the final value for each combination of entry, site, replication, and growing period.\nThe second element is a Vector{String} containing the combinations that were skipped due to insufficient data points.\n\nNotes\n\nThe input DataFrame must contain the required columns specified in the global variable REQUIRED_COLUMNS = [\"entries\", \"sites\", \"replications\", \"growing_periods\", \"time_points\"], as well as at least one additional trait column.\nIf the DataFrame contains more than one trait column, only the first trait column will be used.\nCombinations with fewer than min_t time points will be skipped.\nThe function uses a progress bar to indicate the fitting process if verbose=true.\nThe optimisation is performed using the BBO_adaptive_de_rand_1_bin_radiuslimited() algorithm (details of the optimisation algorithm).\nThe optimisation algorithm minimises the mean squared error between the observed data y and the generalised logistic model. \n\nDetails\n\nFits a generalised logistic growth model to the data using the following equation:\n\ny(t) = A + fracK-AC + (Qe^-Bt)^1v\n\nwhere:\n\ny(t): biomass at time t\nA: lower asymptote (initial or minimum biomass)\nK: positively affects the upper asymptote (can be the final or maximum biomass if C = 100, since y_max = A + (K-A)C^(1v), then y_max = A + K - A, therefore: y_max = K)\nC: negatively affects the final or maximum biomass\nQ: negatively affects initial or minimum biomass\ne: Euler's number (~2.71828)\nB: growth rate\nv: asymmetry parameter (v  0; small values: fast growth early; large values: fast growth later)\n\nAdditional information are provided in the output DataFrame:\n\ny_t0 is the value of the growth model at time t = 0\ny_max is the maximum value of the growth model (y_max = A + (K-A)C^(1v))\nOne of the following fit statistic such as R² (default), RMSE, MSE, MAE, and Pearson's correlation coefficient (ρ)\n\nExample\n\njulia> df = simulate(n_entries=5, seed=42);\n\njulia> df_out, skipped_combinations = fitgrowthmodels(df);\n\njulia> length(unique(df.entries)) == length(unique(df_out.entries))\ntrue\n\njulia> length(unique(df.sites)) == length(unique(df_out.sites))\ntrue\n\njulia> length(unique(df.replications)) == length(unique(df_out.replications))\ntrue\n\njulia> length(unique(df.growing_periods)) == length(unique(df_out.growing_periods))\ntrue\n\njulia> all(x -> x ∈ names(df_out), [\"A\", \"K\", \"C\", \"Q\", \"B\", \"v\", \"y_max\", \"R²\", \"time_to_50p\", \"time_to_90p\"])\ntrue\n\njulia> (var(df_out.A) > 0.0) && (var(df_out.K) > 0.0) && (var(df_out.C) == 0.0) && (var(df_out.Q) == 0.0) && (var(df_out.B) > 0.0) && (var(df_out.v) > 0.0)\ntrue\n\njulia> (var(df_out.y_max) > 0.0) && (var(df_out.\"R²\") > 0.0) && (var(df_out.time_to_50p) > 0.0) && (var(df_out.time_to_90p) > 0.0)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#CropGrowth.fitstatistics-Tuple{}","page":"Home","title":"CropGrowth.fitstatistics","text":"fitstatistics(; y::Vector{Float64}, ŷ::Vector{Float64})::Dict{String, Float64}\n\nCompute various fit statistics for a given set of observed and predicted values.\n\nArguments\n\ny::Vector{Float64}: Observed data points.\nŷ::Vector{Float64}: Predicted data points.\n\nReturns\n\nA dictionary containing the following fit statistics:\n\n\"R²\": Coefficient of determination, a measure of how well the predicted values explain the variance in the observed data.\n\"rmse\": Root mean squared error, a measure of the average magnitude of the residuals.\n\"mse\": Mean squared error, the average of the squared residuals.\n\"mae\": Mean absolute error, the average of the absolute residuals.\n\"ρ\": Pearson correlation coefficient between the observed and predicted values.\n\nNotes\n\nEnsure that the y and ŷ vectors are of the same length and correspond to the same observations.\nThe function assumes that both y and ŷ are non-empty vectors.\n\nExample\n\njulia> y1::Vector{Float64} = rand(10); y2::Vector{Float64} = rand(10);\n\njulia> stats0 = fitstatistics(y=y1, ŷ=y1);\n\njulia> stats1 = fitstatistics(y=y1, ŷ=y2);\n\njulia> stats0[\"R²\"] > stats1[\"R²\"]\ntrue\n\njulia> stats0[\"rmse\"] < stats1[\"rmse\"]\ntrue\n\njulia> stats0[\"mse\"] < stats1[\"mse\"]\ntrue\n\njulia> stats0[\"mae\"] < stats1[\"mae\"]\ntrue\n\njulia> stats0[\"ρ\"] > stats1[\"ρ\"]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#CropGrowth.generalisedlogistic-Tuple{GrowthModel}","page":"Home","title":"CropGrowth.generalisedlogistic","text":"generalisedlogistic(growth_model::GrowthModel; t::Vector{Float64})::Vector{Float64}\n\nComputes the generalised logistic function for a given vector of time points t using the parameters defined in the GrowthModel.\n\nArguments\n\ngrowth_model::GrowthModel: A struct containing the parameters for the generalised logistic function.\nt::Vector{Float64}: A vector of time points at which to evaluate the function.\n\nReturns\n\nVector{Float64}: A vector of values representing the generalised logistic function evaluated at each time point in t.\n\nReturns\n\nVector{Float64}: A vector of values representing the generalised logistic function evaluated at each time point in t.\n\nExample\n\njulia> t = collect(0.0:1.0:10.0);\n\njulia> growth_model = GrowthModel(A=0.0, K=10.0, C=1.0, Q=1.0, B=0.75, v=0.1);\n\njulia> y = generalisedlogistic(growth_model, t=t);\n\njulia> (y[1] == minimum(y)) && (y[end] == maximum(y))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#CropGrowth.generalisedlogistic-Tuple{Vector{Float64}}","page":"Home","title":"CropGrowth.generalisedlogistic","text":"generalisedlogistic(t::Vector{Float64}; A=0.0, K=1.0, C=1.0, Q=1.0, B=1.0, v=1.0)::Vector{Float64}\n\nComputes the generalised logistic function for a given vector of time points t.\n\nArguments\n\nt::Vector{Float64}: A vector of time points at which to evaluate the function.\n\nKeyword Arguments\n\nA::Float64 (default: 0.0): lower asymptote (initial or minimum biomass)\nK::Float64 (default: 1.0): upper asymptote (can be the final or maximum biomass if C = 100, since y_max = A + (K-A)C^(1v), then y_max = A + K - A, therefore: y_max = K)\nC::Float64 (default: 1.0): negatively affects the final or maximum biomass\nQ::Float64 (default: 1.0): negatively affects initial or minimum biomass\nB::Float64 (default: 1.0): growth rate\nv::Float64 (default: 1.0): asymmetry parameter (v  0; small values: fast growth early; large values: fast growth later)\n\nReturns\n\nVector{Float64}: A vector of values representing the generalised logistic function evaluated at each time point in t.\n\nExample\n\njulia> t = collect(0.0:1.0:10.0);\n\njulia> y = generalisedlogistic(t; A=0.0, K=10.0, C=1.0, Q=1.0, B=0.75, v=0.1);\n\njulia> (y[1] == minimum(y)) && (y[end] == maximum(y))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#CropGrowth.modelgrowth-Tuple{}","page":"Home","title":"CropGrowth.modelgrowth","text":"modelgrowth(; \n    y::Vector{Float64}, \n    t::Vector{Float64}, \n    θ_search_space::Dict{String, Dict{Symbol, Float64}}, \n    maxiters::Int64=10_000, \n    seed::Int64=42, \n    verbose::Bool=false\n)::GrowthModel\n\nFit a generalised logistic growth model to the given data y over time t.\n\nArguments\n\ny::Vector{Float64}: The observed data points representing the growth values.\nt::Vector{Float64}: The corresponding time points for the observed data.\nθ_search_space::Dict{String, Dict{Symbol, Float64}}: A dictionary defining the search space for each parameter of the generalised logistic model. Each key corresponds to a parameter name (\"A\", \"K\", \"C\", \"Q\", \"B\", \"v\"), and the value is another dictionary with keys :init, :lower, and :upper specifying the initial value, lower bound, and upper bound for that parameter.\nmaxiters::Int64=10_000: The maximum number of iterations for the optimisation algorithm. Defaults to 10,000.\nseed::Int64=42: The random seed for reproducibility. Defaults to 42.\nverbose::Bool=false: If true, prints the fitted parameters, fit statistics, and displays a plot of the fitted model. Defaults to false.\n\nReturns\n\nGrowthModel: A structure containing the fitted parameters of the generalised logistic growth model and fit statistics.\n\nDetails\n\nThe function uses an optimisation algorithm to minimise the mean squared error between the observed data y and the generalised logistic model. \nThe model parameters are constrained within bounds specified in the θ_search_space dictionary.\nThe optimisation is performed using the BBO_adaptive_de_rand_1_bin_radiuslimited() algorithm (details of the optimisation algorithm).\nThe function also computes fit statistics, which are included in the returned GrowthModel structure.\nIf verbose is set to true, the function prints the fitted parameters, fit statistics, and displays a scatter plot of the observed data along with the fitted curve.\n\nNotes\n\ny_max may be unexpectedly high if C is fitted freely which may indicate a simple linear growth rather than a logistic growth pattern.\nIf y_max is desired to be equal to K, set C = 1.0 when defining the θ_search_space, i.e. In θ_search_space define \"C\" => Dict(:init=>1.0, :lower=>1.0, :upper=>1.0).\n\nExample\n\njulia> t = collect(1.0:10.0);\n\njulia> growth_model_1 = modelgrowth(t=t, y=sort(vcat([0.0, 0.0, 1.0, 1.0], rand(6))));\n\njulia> growth_model_2 = modelgrowth(t=t, y=rand(10));\n\njulia> growth_model_1.fit_statistics[\"R²\"] > growth_model_2.fit_statistics[\"R²\"]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#CropGrowth.readdelimited-Tuple{}","page":"Home","title":"CropGrowth.readdelimited","text":"readdelimited(; fname::String, delim::Union{Char,String} = \"\t\", trait_name::String = \"biomass\")::DataFrame\n\nReads a delimited file into a DataFrame and validates its structure.\n\nArguments\n\nfname::String: The path to the file to be read.\ndelim::Union{Char,String}: The delimiter used in the file. Defaults to tab (\"\t\").\ntrait_name::String: The name of the trait column to validate. Defaults to \"biomass\".\n\nReturns\n\nA DataFrame containing the data from the file with the following required columns:\nentries\nsites\nreplications\ngrowing_periods\ntime_points\nThe column specified by trait_name\n\nThrows\n\nArgumentError: If the file does not exist.\nArgumentError: If any of the REQUIRED_COLUMNS = [\"entries\", \"sites\", \"replications\", \"growing_periods\", \"time_points\"], including trait_name, are missing.\n\nNotes\n\nThe function expects the file to contain specific REQUIRED_COLUMNS = [\"entries\", \"sites\", \"replications\", \"growing_periods\", \"time_points\"], defined in REQUIRED_COLUMNS, along with the column specified by trait_name.\n\nExample\n\njulia> df = simulate();\n\njulia> CSV.write(\"test.tsv\", df, delim=\"\t\");\n\njulia> df_read = readdelimited(fname=\"test.tsv\", delim=\"\t\", trait_name=\"biomass\");\n\njulia> isequal(df, df_read)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#CropGrowth.simulate-Tuple{}","page":"Home","title":"CropGrowth.simulate","text":"simulate(; \n    n_entries::Int64 = 100, \n    n_sites::Int64 = 2, \n    n_replications::Int64 = 3, \n    n_growing_periods::Int64 = 4, \n    n_time_points_per_growing_period::Int64 = 10, \n    seed::Int64 = 42\n)::DataFrame\n\nSimulates crop growth data and returns it as a DataFrame. The function generates synthetic data for multiple entries, sites, replications, growing periods, and time points, with random biomass values.\n\nKeyword Arguments\n\nn_entries::Int64: Number of crop entries to simulate (default: 100).\nn_sites::Int64: Number of sites to simulate (default: 2).\nn_replications::Int64: Number of replications per site (default: 3).\nn_growing_periods::Int64: Number of growing periods per replication (default: 4).\nn_time_points_per_growing_period::Int64: Number of time points per growing period (default: 10).\nseed::Int64: Random seed for reproducibility (default: 42).\n\nReturns\n\nA DataFrame with the following columns:\n\nentries: Crop entry identifiers.\nsites: Site identifiers.\nreplications: Replication identifiers.\ngrowing_periods: Growing period identifiers.\ntime_points: Time points within each growing period.\nbiomass: Simulated biomass values.\n\nExample\n\njulia> df = simulate(n_entries=5, n_sites=1, n_replications=1, n_growing_periods=1, n_time_points_per_growing_period=5, trait_name=\"some_trait_name\", seed=123);\n\njulia> size(df)\n(25, 6)\n\njulia> var(df.some_trait_name) > 0.0\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#CropGrowth.timetomaxperc-Tuple{GrowthModel}","page":"Home","title":"CropGrowth.timetomaxperc","text":"timetomaxperc(growth_model::GrowthModel; p::Vector{Float64} = [0.5])::Vector{Float64}\n\nCalculate the time required for a growth model to reach a proportion p of its carrying capacity K.\n\nArguments\n\ngrowth_model::GrowthModel: An instance of the GrowthModel type containing the parameters of the growth model.\np::Vector{Float64}: A vector of proportions (default is [0.5]) representing the fraction of the carrying capacity (y_max) to compute the time for.\n\nReturns\n\nVector{Float64}: A vector of times corresponding to each proportion in p.\n\nDetails\n\nThe function computes the maximum value of the growth model (y_max = A + (K-A)C^(1v)) based on its parameters.\nFor each proportion in p, the corresponding value of y is calculated as p * y_max.\nThe time required to reach each y is computed using the generalised logistic growth model formula, which involves logarithmic and complex arithmetic operations.\nThe result is the real part of the computed times.\nThe formula is:\n\nt = -frac1B cdot ln left( fracleft( left( fracK - Ay - A right)^v - C right)Q right)\n\nNotes\n\nThe function assumes that the GrowthModel instance contains the parameters A, K, C, Q, B, and v.\nThe computation may involve complex numbers, but only the real part of the result is returned.\n\nExample\n\njulia> growth_model = modelgrowth(t=collect(1.0:10.0), y=sort(vcat([0.0, 0.0, 1.0, 1.0], rand(6))));\n\njulia> p = [0.5, 0.95, 0.99];\n\njulia> time_to_Kp = timetomaxperc(growth_model; p=p);\n\njulia> ŷ = generalisedlogistic(growth_model, t=time_to_Kp);\n\njulia> all( abs.(ŷ .- (p .* growth_model.y_max)) .< 1e-5 )\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#CropGrowth.writedelimited-Tuple{DataFrames.DataFrame}","page":"Home","title":"CropGrowth.writedelimited","text":"writedelimited(df::DataFrame; fname::String, delim::Union{Char,String} = \"\t\", overwrite::Bool = false)::Nothing\n\nWrites the contents of a DataFrame to a delimited text file.\n\nArguments\n\ndf::DataFrame: The data frame to be written to the file. Must contain the required columns:\nentries\nsites\nreplications\ngrowing_periods\ntime_points\n1 additional column representing the trait data\nfname::String: The name of the output file, including its path if necessary.\ndelim::Union{Char,String}: The delimiter to use in the output file. Defaults to a tab character (\"\t\").\noverwrite::Bool: Whether to overwrite the file if it already exists. Defaults to false.\n\nReturns\n\nNothing: This function does not return a value.\n\nExample\n\njulia> df = simulate();\n\njulia> fname = writedelimited(df, fname=\"test.tsv\", delim=\"\t\", overwrite=true);\n\njulia> isfile(fname)\ntrue\n\njulia> df_read = readdelimited(fname=\"test.tsv\", delim=\"\t\", trait_name=\"biomass\");\n\njulia> isequal(df, df_read)\ntrue\n\n\n\n\n\n","category":"method"}]
}
